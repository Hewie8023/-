### 给一个有序数组，求中位数
定义中位数为一个有序数组(len(array)+1)//2处的元素
1. 排序取中值
2. 利用快排的思想
1）先进行一趟快排，使得div左边的值都比arr[div]小，div右边的值都比arr[ddiv]大，但是这个div的位置是不确定的，可能位于中间，可能偏左或者偏右；
2）计算出mid所在的下标，如果是奇数则mid = (size + 1) / 2，如果是偶数则mid = size / 2;
3）此时需要比较mid和div所在的位置。如果mid在div所在位置的左边，此时就要递归去左半区间查找；如果mid在div的右边，此时就要递归去右半区间查找；如果恰好相等则说明div/mid所在的位置就是中位数。
```c++
int PartSort(int *arr, int start, int end)
{
    int left = start;
    int right = end;
    int key = arr[end];   //选取关键字
    while (left < right)
    {
        while (left < right && arr[left] <= key)  //左边找比key大的值
        {
            ++left;
        }
        while (left < right && arr[right] >= key)  //右边找比key小的值
        {
            --right;
        }
        if (left < right)
        {
            swap(arr[left], arr[right]);  //找到之后交换左右的值
        }
    }
    swap(arr[right], arr[end]);
    return left;
}
//求一个无序数组的中位数
int GetMidNumNoSort1(int *arr,int size)
{
    assert(arr);
    int start = 0;
    int end = size - 1;
    int mid = (size - 1) / 2;
    int div = PartSort(arr,start,end);
    while (div != mid)
    {
        if (mid < div)   //左半区间找
            div = PartSort(arr, start, div - 1);
        else    //左半区间找
            div = PartSort(arr, div + 1, end);
    }
    return arr[mid];   //找到了
}
```

3. 建堆的思想
步骤 1 ：如果数组长度为奇数则取数组的前 (len(array)+1)//2 个元素建立 一个最小堆，如果为偶数则取(len(array)+1)//2 +1个元素建立 一个最小堆。
步骤 2 ：遍历剩余元素，如果该元素小于堆顶元素，则丢弃或不作处理；如果该元素大于堆顶元素，则将其取代堆顶元素，并且重新调整当前堆为最小堆。
步骤 3 ：遍历结束后，返回堆顶元素，它就是所要寻找的中位数。

### 随时找到数据流的中位数
用一个大根堆和一个小根堆
大根堆中含有接收的所有数中较小的一半，并且按大根堆的方式组织起来，那么大根堆的堆顶就是较小一半的数中最大的一个。
小根堆中含有接收的所有数中较大的一半，并且按小根堆的方式组织起来，那么小根堆的堆顶就是较大一半的数中最小的一个。
中位数就是两个堆顶相加除以2。

要满足：
1. 如果大根堆的size比小根堆的size大2，那么从大根堆里将堆顶弹出并放入小根堆里；
2. 如果小根堆的size比大根堆的size大2，那么从小根堆里将堆顶弹出并放入大根堆里。

### 给一堆ip区间和每个区间对应的地点（区间不重合），再任意给一个具体的ip，查出对应的地点。
使用二分查找的变种
IP地址转化为32位整型数，将起始地址从小到大进行排序。
![]()
要查找某个IP对应的地区时，通过二分查找，找到最后一个起始地址IP小于等于这个IP的IP区间。
若IP在这个区间内，则找到；否者就是没有找到
**二分查找的变种问题：**
https://blog.csdn.net/qq_25800311/article/details/89328326

### 上题中，若区间重合，怎么做。
总体步骤和上面一样。
最后在验证的时候，需要判断得到结果的重合的区间。



